# Copyright 2021 Prayas Energy Group(https://www.prayaspune.org/peg/)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

EndUseDemandEnergy:
  filetype: csv
  columns:
    EnergyCarrier:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    Year:
      type: int
      min: 2000
      max: 2100
    Season:
      type: str
      optional: True
    DayType:
      type: str
      optional: True
    DaySlice:
      type: str
      optional: True
    EndUseDemandEnergy:
      type: float
      min: 0
  dependencies: # names of parameters either from common or from this file
    - ModelPeriod
    - PhysicalPrimaryCarriers
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(EnergyCarrier, concat(get_col(PhysicalPrimaryCarriers,'EnergyCarrier'), get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: EnergyCarrier in EndUseDemandEnergy must be one of those specified in Common but not from NonPhysicalPrimaryCarriers
    - code: check_enduse("Geographic validity", utilities.check_geographic_validity, EndUseDemandEnergy, 'EndUseDemandEnergy', ['EnergyCarrier'], True, True)
      message: Geographic columns have error in EndUseDemandEnergy
    - code: check_enduse("Time validity", utilities.check_time_validity, EndUseDemandEnergy, 'EndUseDemandEnergy', ['EnergyCarrier'], True, True)
      message: Time columns have error in EndUseDemandEnergy
    - code: check_balancing_area('EndUseDemandEnergy', EndUseDemandEnergy, 'EnergyCarrier', False)
      message: Geographic granularity for one or more EnergyCarrier in EndUseDemandEnergy is finer than the balancing area
    - code: check_balancing_time('EndUseDemandEnergy', EndUseDemandEnergy, 'EnergyCarrier', False)
      message: Time granularity for one or more EnergyCarrier in EndUseDemandEnergy is finer than the balancing time

      
EC_InfoGranularity:
  filetype: csv
  columns:
    EnergyCarrier:
      type: str
    GeographicGranularity:
      type: str
    TimeGranularity:
      type: str
  dependencies:
    - PhysicalPrimaryCarriers
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  validation:
    - code: unique(EnergyCarrier)
      message: In EC_InfoGranularity, EnergyCarrier must not be repeated
    - code: x_in_y(EnergyCarrier, concat(get_col(PhysicalPrimaryCarriers,'EnergyCarrier'), get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: EnergyCarrier in EC_InfoGranularity must be one of those specified in PhysicalPrimaryCarriers or PhysicalDerivedCarriers or NonPhysicalDerivedCarriers
    - code: x_in_y(TimeGranularity, utilities.get_valid_time_levels())
      message: In EC_InfoGranularity, Time granularity has to be one of these strings YEAR, SEASON, DAYTYPE, DAYSLICE
    - code: x_in_y(GeographicGranularity, utilities.get_valid_geographic_levels())
      message: In EC_InfoGranularity,Geographic granularity has to be one of these strings MODELGEOGRAPHY,SUBGEOGRAPHY1, SUBGEOGRAPHY2, SUBGEOGRAPHY3
    - code: check_balancing_area_gran('EC_InfoGranularity', EC_InfoGranularity, 'EnergyCarrier','coarser')
      message: Geographic granularity for one or more EnergyCarrier specified in EC_InfoGranularity is incorrect. Check log for more details      
    - code: check_balancing_time_gran('EC_InfoGranularity', EC_InfoGranularity, 'EnergyCarrier','coarser')
      message: Time granularity for one or more EnergyCarrier specified in EC_InfoGranularity is incorrect. Check log for more details

      
EC_ConstraintsGranularity:
  filetype: csv
  optional: True
  columns:
    EnergyCarrier:
      type: str
    GeographicGranularity:
      type: str
    TimeGranularity:
      type: str
  dependencies:
    - PhysicalPrimaryCarriers
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  validation:
    - code: unique(EnergyCarrier)
      message: In EC_ConstraintsGranularity, EnergyCarrier must not be repeated
    - code: x_in_y(EnergyCarrier, concat(get_col(PhysicalPrimaryCarriers,'EnergyCarrier'), get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: EnergyCarrier in EC_ConstraintsGranularity must be one of those specified in PhysicalPrimaryCarriers, PhysicalDerivedCarriers or NonPhysicalDerivedCarriers
    - code: x_in_y(TimeGranularity, utilities.get_valid_time_levels())
      message: In EC_ConstraintsGranularity, Time granularity has to be one of these strings YEAR, SEASON, DAYTYPE, DAYSLICE
    - code: x_in_y(GeographicGranularity, utilities.get_valid_geographic_levels())
      message: In EC_ConstraintsGranularity, Geographic granularity has to be one of these strings MODELGEOGRAPHY,SUBGEOGRAPHY1, SUBGEOGRAPHY2, SUBGEOGRAPHY3
    

ECT_InfoGranularity:
  filetype: csv
  optional: True
  columns:
    EnergyConvTech:
      type: str
    GeographicGranularity:
      type: str
    TimeGranularity:
      type: str
  dependencies:
    - EnergyConvTechnologies
  validation:
    - code: unique(EnergyConvTech)
      message: In ECT_InfoGranularity, EnergyConvTech must not be repeated
    - code: x_in_y(EnergyConvTech, get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: EnergyConvTech in ECT_InfoGranularity must be one of those specified in EnergyConvTechnologies
    - code: x_in_y(TimeGranularity, utilities.get_valid_time_levels())
      message: In EC_InfoGranularity, Time granularity has to be one of these strings YEAR, SEASON, DAYTYPE, DAYSLICE
    - code: x_in_y(GeographicGranularity, utilities.get_valid_geographic_levels())
      message: In EC_InfoGranularity, Geographic granularity has to be one of these strings MODELGEOGRAPHY,SUBGEOGRAPHY1, SUBGEOGRAPHY2, SUBGEOGRAPHY3
    - code: check_balancing_area_gran('ECT_InfoGranularity', ECT_InfoGranularity, 'EnergyConvTech','coarser')
      message: Geographic granularity for one or more EnergyConvTech specified in ECT_InfoGranularity is incorrect. Check log for more details      
    - code: check_balancing_time_gran('ECT_InfoGranularity', ECT_InfoGranularity, 'EnergyConvTech','coarser')
      message: Time granularity for one or more EnergyConvTech specified in ECT_InfoGranularity is incorrect. Check log for more details
# if EnergyConvtechnologies is given then this has to be given and vice versa.
      

ECT_InputsGranularity:
  filetype: csv
  optional: True
  columns:
    EnergyConvTech:
      type: str
    GeographicGranularity:
      type: str
    TimeGranularity:
      type: str
  dependencies:
    - EnergyConvTechnologies
  validation:
    - code: unique(EnergyConvTech)
      message: In ECT_InputsGranularity, EnergyConvTech must not be repeated
    - code: x_in_y(EnergyConvTech, get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: EnergyConvTech in ECT_InputsGranularity must be one of those specified in EnergyConvTechnologies
    - code: x_in_y(TimeGranularity, utilities.get_valid_time_levels())
      message: In ECT_InputsGranularity, Time granularity has to be one of these strings YEAR, SEASON, DAYTYPE, DAYSLICE
    - code: x_in_y(GeographicGranularity, utilities.get_valid_geographic_levels())
      message: In ECT_InputsGranularity, Geographic granularity has to be one of these strings MODELGEOGRAPHY,SUBGEOGRAPHY1, SUBGEOGRAPHY2, SUBGEOGRAPHY3
    - code: check_balancing_area_gran('ECT_InputsGranularity', ECT_InputsGranularity, 'EnergyConvTech','finer')
      message: Geographic granularity for one or more EnergyConvTech specified in ECT_InputsGranularity is incorrect. Check log for more details      
    # check for balancing time is not put because, it is irrelevant here and will also fail if we put it.
# if EnergyConvtechnologies is given then this has to be given and vice versa.

    
EST_InfoGranularity:
  filetype: csv
  optional: True
  columns:
    EnergyStorTech:
      type: str
    GeographicGranularity:
      type: str
    TimeGranularity:
      type: str
  dependencies:
    - EnergyStorTechnologies
  validation:
    - code: unique(EnergyStorTech)
      message: In EST_InfoGranularity, EnergyStorTech must not be repeated
    - code: x_in_y(EnergyStorTech, get_col(EnergyStorTechnologies,'EnergyStorTech'))
      message: EnergyStorTech in EST_InfoGranularity must be one of those specified in EnergyStorTechnologies
    - code: x_in_y(TimeGranularity, utilities.get_valid_time_levels())
      message: In EST_InfoGranularity, Time granularity has to be one of these strings YEAR, SEASON, DAYTYPE, DAYSLICE
    - code: x_in_y(GeographicGranularity, utilities.get_valid_geographic_levels())
      message: In EST_InfoGranularity, Geographic granularity has to be one of these strings MODELGEOGRAPHY,SUBGEOGRAPHY1, SUBGEOGRAPHY2, SUBGEOGRAPHY3
    - code: check_balancing_area_gran('EST_InfoGranularity', EST_InfoGranularity, 'EnergyStorTech','coarser')
      message: Geographic granularity for one or more EnergyStorTech specified in EST_InfoGranularity is incorrect. Check log for more details      
    - code: check_balancing_time_gran('EST_InfoGranularity', EST_InfoGranularity, 'EnergyStorTech','coarser')
      message: Time granularity for one or more EnergyStorTech specified in EST_InfoGranularity is incorrect. Check log for more details
# if EnergyStorTechnologies is given then this has to be given and vice versa.

    
EST_InputsGranularity:
  filetype: csv
  optional: True
  columns:
    EnergyStorTech:
      type: str
    GeographicGranularity:
      type: str
    TimeGranularity:
      type: str
  dependencies:
    - EnergyStorTechnologies
  validation:
    - code: unique(EnergyStorTech)
      message: In EST_InputsGranularity, EnergyStorTech must not be repeated
    - code: x_in_y(EnergyStorTech, get_col(EnergyStorTechnologies,'EnergyStorTech'))
      message: EnergyStorTech in EST_InputsGranularity must be one of those specified in EnergyStorTechnologies
    - code: x_in_y(TimeGranularity, utilities.get_valid_time_levels())
      message: In EST_InputsGranularity, Time granularity has to be one of these strings YEAR, SEASON, DAYTYPE, DAYSLICE
    - code: x_in_y(GeographicGranularity, utilities.get_valid_geographic_levels())
      message: In EST_InputsGranularity, Geographic granularity has to be one of these strings MODELGEOGRAPHY,SUBGEOGRAPHY1, SUBGEOGRAPHY2, SUBGEOGRAPHY3
    - code: check_balancing_area_gran('EST_InputsGranularity', EST_InputsGranularity, 'EnergyStorTech','finer')
      message: Geographic granularity for one or more EnergyStorTech specified in EST_InputsGranularity is incorrect. Check log for more details      
    # check for balancing time is not put because, it is irrelevant here and will also fail if we put it.
# if EnergyStorTechnologies is given then this has to be given and vice versa.
    
PEC_Info:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Carriers
  time: coarse
  geographic: coarse
  optional: True
  # because of this check in Common, PPEC or NPPEC and DEC, this parameter can be optional
  # but will have issue if PPEC is defined and at least one PPEC is used in supply.
  columns:
    EnergyCarrier:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    Year:
      type: int
      min: 2000
      max: 2100
    Season:
      type: str
      optional: True
    DayType:
      type: str
      optional: True
    DaySlice:
      type: str
      optional: True
    NonEnergyShare:
      type: float
      min: 0
      max: 1
    DomesticPrice:
      type: float
      min: 0
    AVTaxOHDom:
      type: float
      min: 0
    FixedTaxOHDom:
      type: float
      min: 0
    ImportPrice:
      type: float
      min: 0
    AVTaxOHImp:
      type: float
      min: 0
    FixedTaxOHImp:
      type: float
      min: 0
  
  dependencies:
    - ModelPeriod
    - EC_InfoGranularity
    - PhysicalPrimaryCarriers
  filterqueries:
      - Year >= {ModelPeriod.StartYear.iloc[0]}
      - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyCarrier,y=get_col(PhysicalPrimaryCarriers,'EnergyCarrier'))
      message: In PEC_Info, every entry in EnergyCarrier column should be from PhysicalPrimaryCarriers
    - code: x_in_y(x=EnergyCarrier,y=get_col(EC_InfoGranularity,'EnergyCarrier'))
      message: In PEC_Info, every entry in EnergyCarrier column should be from EC_InfoGranularity
    - code: check_granularity(PEC_Info, EC_InfoGranularity, 'EnergyCarrier', GSTAR=True, TSTAR=True)
      message: One or more granularities specified in PEC_Info are incorrect.
    - code: utilities.check_geographic_validity(PEC_Info, 'PEC_Info', ['EnergyCarrier'])
      message: Geographic columns have error in PEC_Info
    - code: utilities.check_time_validity(PEC_Info, 'PEC_Info', ['EnergyCarrier'])
      message: Time columns have error in PEC_Info
    - code: utilities.unique_across(PEC_Info,['EnergyCarrier'])
      message: In PEC_Info, data for one or more EnergyCarrier has duplicate entries

# if physicalprimarycarriers is given then this parameter has to be given and vice versa

    
PEC_ProdImpConstraints:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Carriers
  optional: True
  # because of this check in Common, PPEC or NPPEC and DEC, this parameter can be optional
  # but will have issue if PPEC is defined and at least one PPEC is used in supply.
  entities:
    - EnergyCarrier
  preapply: rumi.io.utilities.expand_ALL
  granularity_exception: True 
  columns:
    EnergyCarrier:
    ModelGeography:
    SubGeography1:
      optional: True
    SubGeography2:
      optional: True
    SubGeography3:
      optional: True
    Year:
    Season:
      optional: True
    DayType:
      optional: True
    DaySlice:
      optional: True
    MaxDomesticProd:
      min: 0
    MaxImport:
      min: 0
  dependencies:
    - ModelPeriod
    - EC_ConstraintsGranularity
    - PhysicalPrimaryCarriers
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyCarrier,y=get_col(PhysicalPrimaryCarriers,'EnergyCarrier'))
      message: In PEC_ProdImpConstraints, every entry in EnergyCarrier column should be from PhysicalPrimaryCarriers
    - code: x_in_y(x=EnergyCarrier,y=get_col(EC_ConstraintsGranularity,'EnergyCarrier'))
      message: In PEC_ProdImpConstraints, every entry in EnergyCarrier column should be from EC_ConstraintsGranularity    
    - code: check_granularity(PEC_ProdImpConstraints, EC_ConstraintsGranularity, 'EnergyCarrier', GSTAR=True, TSTAR=True)
      message: One or more granularities specified in PEC_ProdImpConstraints are incorrect.
    - code: utilities.check_CGT_validity(PEC_ProdImpConstraints, 'PEC_ProdImpConstraints', ['EnergyCarrier'], "CGT")
      message: Geographic and Time columns have error in PEC_ProdImpConstraints
    - code: utilities.unique_across(PEC_ProdImpConstraints,['EnergyCarrier'])
      message: In PEC_ProdImpConstraints, data for one or more EnergyCarrier has duplicate entries
# if physicalprimarycarriers is given then this parameter has to be given and vice versa


DEC_ImpConstraints:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Carriers
  optional: True
  # because of this check in Common, PPEC or NPPEC and DEC, this parameter can be optional
  # but will have issue if PPEC is defined and at least one PPEC is used in supply.
  entities:
    - EnergyCarrier
  preapply: rumi.io.utilities.expand_ALL
  granularity_exception: True
  columns:
    EnergyCarrier:
    ModelGeography:
    SubGeography1:
      optional: True
    SubGeography2:
      optional: True
    SubGeography3:
      optional: True
    Year:
    Season:
      optional: True
    DayType:
      optional: True
    DaySlice:
      optional: True
    MaxImport:
      min: 0
  dependencies:
    - ModelPeriod
    - EC_ConstraintsGranularity
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyCarrier,y=concat(get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: In DEC_ImpConstraints, every entry in EnergyCarrier column should be from PhysicalDerivedCarriers, NonPhysicalDerivedCarriers
    - code: x_in_y(x=EnergyCarrier,y=get_col(EC_ConstraintsGranularity,'EnergyCarrier'))
      message: In DEC_ImpConstraints, every entry in EnergyCarrier column should be from EC_ConstraintsGranularity    
    - code: check_granularity(DEC_ImpConstraints, EC_ConstraintsGranularity, 'EnergyCarrier', GSTAR=True, TSTAR=True)
      message: One or more granularities specified in DEC_ImpConstraints are incorrect.
    - code: utilities.check_CGT_validity(DEC_ImpConstraints, 'DEC_ImpConstraints', ['EnergyCarrier'], "CGT")
      message: Geographic and Time columns have error in DEC_ImpConstraints
    - code: utilities.unique_across(DEC_ImpConstraints,['EnergyCarrier'])
      message: In DEC_ImpConstraints, data for one or more EnergyCarrier has duplicate entries


DEC_Info:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Carriers
  time: coarse
  geographic: coarse
  optional: True
  # because of this check in Common, PPEC or NPPEC and DEC, this parameter can be optional
  # but will have issue if DEC is defined and at least one DEC is used in supply.
  columns:
    EnergyCarrier:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    Year:
      type: int
      min: 2000
      max: 2100
    Season:
      type: str
      optional: True
    DayType:
      type: str
      optional: True
    DaySlice:
      type: str
      optional: True
    FixedTaxOHDom:
      type: float
      min: 0
    ImportPrice:
      type: float
      min: 0
    AVTaxOHImp:
      type: float
      min: 0
    FixedTaxOHImp:
      type: float
      min: 0

  dependencies:
    - ModelPeriod
    - EC_InfoGranularity
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyCarrier,y=concat(get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: In DEC_Info, every entry in EnergyCarrier column should be from Derived Carriers
    - code: x_in_y(x=EnergyCarrier,y=get_col(EC_InfoGranularity,'EnergyCarrier'))
      message: In DEC_Info, every entry in EnergyCarrier column should be from EC_InfoGranularity
    - code: check_granularity(DEC_Info, EC_InfoGranularity, 'EnergyCarrier',GSTAR=True, TSTAR=True)
      message: One or more granularities specified in DEC_Info are incorrect.
    - code: utilities.check_geographic_validity(DEC_Info, 'DEC_Info', ['EnergyCarrier'])
      message: Geographic columns have error in DEC_Info
    - code: utilities.check_time_validity(DEC_Info, 'DEC_Info', ['EnergyCarrier'])
      message: Time columns have error in DEC_Info
    - code: utilities.unique_across(DEC_Info,['EnergyCarrier'])
      message: In DEC_Info, data for one or more EnergyCarrier has duplicate entries
# if any of PhysicalDerivedCarriers or NonPhysicalDerivedCarriers is present this has to be given.
# if non of them is present this should not be given

    
EnergyConvTechnologies:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  optional: True
  columns:
    EnergyConvTech:
      type: str
    CapacityUnit:
      type: str
    InputEC:
      type: str
    OutputDEC:
      type: str
    AnnualOutputPerUnitCapacity:
      type: float
      min: 0
  dependencies:
    - PhysicalPrimaryCarriers
    - NonPhysicalPrimaryCarriers
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  validation:
    - code: unique(EnergyConvTech)
      message: In EnergyConvTechnologies, EnergyConvTech must have unique names
    - code: x_in_y(InputEC, concat(get_col(PhysicalPrimaryCarriers,'EnergyCarrier'), get_col(NonPhysicalPrimaryCarriers,'EnergyCarrier'), get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: InputEC in EnergyConvTechnologies, must use only the defined EnergyCarriers in Common
    - code: x_in_y(OutputDEC, concat(get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: OutputDEC in EnergyConvTechnologies, must be one of those specified in PhysicalDerivedCarriers or NonPhysicalDerivedCarriers
    - code: (AnnualOutputPerUnitCapacity > 0).all()
      message: AnnualOutputPerUnitCapacity in EnergyConvTechnologies must be a positive real number
# if any of PhysicalDerivedCarriers or NonPhysicalDerivedCarriers is present this has to be given.
# if non of them is present this should not be given


ECT_CapAddBounds:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  geographic: fine
  optional: True
  columns:
    EnergyConvTech:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    Year:
      type: int
      min: 2000
      max: 2100
    MaxCapacity:
      type: float
      min: -1
    MinCapacity:
      type: float
      min: 0
  dependencies:
    - ModelPeriod
    - ECT_InputsGranularity
    - EnergyConvTechnologies
  filterqueries:
      - Year >= {ModelPeriod.StartYear.iloc[0]}
      - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_CapAddBounds, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: x_in_y(x=EnergyConvTech,y=get_col(ECT_InputsGranularity,'EnergyConvTech'))
      message: In ECT_CapAddBounds, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of ECT_InputsGranularity
    - code: check_granularity(ECT_CapAddBounds, ECT_InputsGranularity, 'EnergyConvTech', GSTAR=True)
      message: One or more granularities specified in ECT_CapAddBounds are incorrect
    - code: utilities.check_geographic_validity(ECT_CapAddBounds, 'ECT_CapAddBounds', ['EnergyConvTech'])
      message: Geographic columns have error in ECT_CapAddBounds
    - code: utilities.check_time_validity(ECT_CapAddBounds, 'ECT_CapAddBounds', ['EnergyConvTech'])
      message: Time columns have error in ECT_CapAddBounds
    - code: utilities.unique_across(ECT_CapAddBounds,['EnergyConvTech'])
      message: In ECT_CapAddBounds, data for one or more EnergyConvTech has duplicate entries
    - code: (MaxCapacity >= MinCapacity).sum()== (MaxCapacity>=0).sum()# this is to take care of -ve maxcap but +ve mincap
      message: In each row of ECT_CapAddBounds MaxCapacity should be greater than or equal to MinCapacity
# if EnergyConvtechnologies is given this has to be given and vice versa.
      
ECT_Lifetime:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  optional: True
  columns:
    EnergyConvTech:
      type: str
    Year:
      type: int
      min: 2000
      max: 2100
    Lifetime:
      type: int
      min: 1    
  dependencies:
    - ModelPeriod
    - EnergyConvTechnologies
  filterqueries:
      - Year >= {ModelPeriod.StartYear.iloc[0]}
      - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_Lifetime, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: utilities.check_time_validity(ECT_Lifetime, 'ECT_Lifetime', ['EnergyConvTech'])
      message: Time columns have error in ECT_Lifetime
    - code: utilities.unique_across(ECT_Lifetime,['EnergyConvTech'])
      message: In ECT_Lifetime, data for one or more EnergyConvTech has duplicate entries
# if EnergyConvtechnologies is given this has to be given and vice versa.

      
ECT_OperationalInfo:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  optional: True
  columns:
    EnergyConvTech:
      type: str
    InstYear:
      type: int
      min: 2000
      max: 2100
    CapacityDerating:
      type: float
      min: 0
      max: 1
    SelfCons:
      type: float
      min: 0
      max: 1
    MaxRampUpRate:
      type: float
      min: 0
      max: 1
    MaxRampDownRate:
      type: float
      min: 0
      max: 1
  dependencies:
    - ModelPeriod
    - EnergyConvTechnologies
  filterqueries:
    - InstYear >= {ModelPeriod.StartYear.iloc[0]-1}
    - InstYear <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_OperationalInfo, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: unique(list(zip(EnergyConvTech,InstYear)))
      message: In ECT_OperationalInfo, combination of EnergyConvTech and InstYear must not be repeated

# if EnergyConvtechnologies is given this has to be given and vice versa.


ECT_EmissionDetails:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  optional: True
  columns:
    EnergyConvTech:
      type: str
    InstYear:
      type: int
      min: 2000
      max: 2100
    EmissionType:
      type: str
    DomEmissionFactor:
      type: float
      min: 0
    ImpEmissionFactor:
      type: float
      min: 0
  dependencies:
    - ModelPeriod
    - EnergyConvTechnologies
    - EmissionTypes
  filterqueries:
    - InstYear >= {ModelPeriod.StartYear.iloc[0]-1}
    - InstYear <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_EmissionDetails, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: all([one_to_one(ECT_EmissionDetails.query(f"EnergyConvTech=='{ECT}'")['InstYear'], range(ModelPeriod.StartYear.iloc[0]-1,ModelPeriod.EndYear.iloc[0]+1)) for ECT in EnergyConvTech.unique()])
      message: Data in ECT_EmissionDetails must be provided for each year from ModelPeriod.StartYear-1 to ModelPeriod.EndYear
    - code: x_in_y(EmissionType, EmissionTypes.EmissionType)
      message: EmissionType in ECT_EmissionDetails must be from EmissionType defined in EmissionTypes in Common
    - code: utilities.unique_across(ECT_EmissionDetails,['EnergyConvTech','InstYear','EmissionType'])
      message: In ECT_EmissionDetails, combination of EnergyConvTech,InstYear and EmissionType must not be repeated
# if EnergyConvtechnologies is not given then should not be given.

      
ECT_EfficiencyCostMaxAnnualUF:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  geographic: coarse
  optional: True
  columns:
    EnergyConvTech:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    InstYear:
      type: int
      min: 2000
      max: 2100
    Year:
      type: int
      min: 2000
      max: 2100
    ConvEff:
      type: float
      min: 0
      max: 1
    FixedCost:
      type: float
      min: 0
    VarCost:
      type: float
      min: 0
    MaxAnnualUF:
      type: float
      min: 0
      max: 1
  dependencies:
    - ModelPeriod
    - ECT_InfoGranularity
    - EnergyConvTechnologies
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
    - InstYear >= {ModelPeriod.StartYear.iloc[0]-1}
    - InstYear <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_EfficiencyCostMaxAnnualUF, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: x_in_y(x=EnergyConvTech,y=get_col(ECT_InfoGranularity,'EnergyConvTech'))
      message: In ECT_EfficiencyCostMaxAnnualUF, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of ECT_InfoGranularity
    - code: check_granularity(ECT_EfficiencyCostMaxAnnualUF, ECT_InfoGranularity, 'EnergyConvTech', GSTAR=True)
      message: One or more granularities specified in ECT_EfficiencyCostMaxAnnualUF are incorrect.
    - code: utilities.check_geographic_validity(ECT_EfficiencyCostMaxAnnualUF, 'ECT_EfficiencyCostMaxAnnualUF', ['EnergyConvTech','InstYear'])
      message: Geographic columns have error in ECT_EfficiencyCostMaxAnnualUF
    - code: utilities.check_time_validity(ECT_EfficiencyCostMaxAnnualUF, 'ECT_EfficiencyCostMaxAnnualUF', ['EnergyConvTech','InstYear'])
      message: Time columns have error in ECT_EfficiencyCostMaxAnnualUF
    - code: utilities.unique_across(ECT_EfficiencyCostMaxAnnualUF,['EnergyConvTech','InstYear'])
      message: In ECT_EfficiencyCostMaxAnnualUF, combination of EnergyConvTech,InstYear must not be repeated
    - code: (Year >= InstYear).all()
      message: In each row for ECT_EfficiencyCostMaxAnnualUF, InstYear should be less than or equal to Year
# if EnergyConvtechnologies is given this has to be given and vice versa.    

ECT_Max_CUF:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  entities:
    - EnergyConvTech
  preapply: rumi.io.utilities.expand_ALL
  time: coarse
  geographic: coarse
  optional: True
  columns:
    EnergyConvTech:
    InstYear:
    ModelGeography:
    SubGeography1:
      optional: True
    SubGeography2:
      optional: True
    SubGeography3:
      optional: True
    Year:
    Season:
      optional: True
    DayType:
      optional: True
    DaySlice:
      optional: True
    MaxUF:
      min: 0
      max: 1
  dependencies:
    - ModelPeriod
    - ECT_InfoGranularity
    - EnergyConvTechnologies
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
    - InstYear >= {ModelPeriod.StartYear.iloc[0]-1}
    - InstYear <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=ECT_Max_CUF.EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_Max_CUF, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: x_in_y(x=ECT_Max_CUF.EnergyConvTech,y=get_col(ECT_InfoGranularity,'EnergyConvTech'))
      message: In ECT_Max_CUF, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of ECT_InfoGranularity    
    - code: check_granularity(ECT_Max_CUF, ECT_InfoGranularity, 'EnergyConvTech', GSTAR=True, TSTAR=True)
      message: One or more granularities specified in ECT_Max_CUF are incorrect.
    - code: utilities.check_CGT_validity(ECT_Max_CUF, 'ECT_Max_CUF', ['EnergyConvTech','InstYear'], "CGT")
      message: Geographic and Time columns have error in ECT_Max_CUF
    - code: utilities.unique_across(ECT_Max_CUF,['EnergyConvTech','InstYear'])
      message: In ECT_Max_CUF, combination of EnergyConvTech,InstYear must not be repeated
    - code: (Year >= InstYear).all()
      message: In each row for ECT_Max_CUF, InstYear should be less than or equal to Year

# if EnergyConvtechnologies is given this has to be given and vice versa.


ECT_LegacyCapacity:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  optional: True
  geographic: fine
  columns:
    EnergyConvTech:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    LegacyCapacity:
      type: float
      min: 0
  dependencies:
    - ECT_InputsGranularity
    - EnergyConvTechnologies
  validation:
    - code: x_in_y(x=ECT_LegacyCapacity.EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_LegacyCapacity, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: x_in_y(x=ECT_LegacyCapacity.EnergyConvTech,y=get_col(ECT_InputsGranularity,'EnergyConvTech'))
      message: In ECT_LegacyCapacity, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of ECT_InputsGranularity    
    - code: check_granularity(ECT_LegacyCapacity, ECT_InputsGranularity, 'EnergyConvTech', GSTAR=True)
      message: One or more granularities specified in ECT_LegacyCapacity are incorrect.
    - code: utilities.check_geographic_validity(ECT_LegacyCapacity, 'ECT_LegacyCapacity', ['EnergyConvTech'])
      message: Geographic columns have error in ECT_LegacyCapacity
    - code: utilities.unique_across(ECT_LegacyCapacity,['EnergyConvTech'])
      message: In ECT_LegacyCapacity, combination of EnergyConvTech and Geographic Columns must not be repeated
# if EnergyConvtechnologies is not given then should not be given.


ECT_LegacyRetirement:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Technologies
  geographic: fine
  optional: True
  columns:
    EnergyConvTech:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    Year:
      type: int
      min: 2000
      max: 2100
    RetCapacity:
      type: float
      min: 0
  dependencies:
    - ModelPeriod
    - ECT_InputsGranularity
    - EnergyConvTechnologies
    - ECT_LegacyCapacity
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=ECT_LegacyRetirement.EnergyConvTech,y=get_col(EnergyConvTechnologies,'EnergyConvTech'))
      message: In ECT_LegacyRetirement, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of EnergyConvTechnologies
    - code: x_in_y(x=ECT_LegacyRetirement.EnergyConvTech,y=get_col(ECT_InputsGranularity,'EnergyConvTech'))
      message: In ECT_LegacyRetirement, every entry in EnergyConvTech columns should be mentioned in EnergyConvTech column of ECT_InputsGranularity
    - code: check_granularity(ECT_LegacyRetirement, ECT_InputsGranularity, 'EnergyConvTech', GSTAR=True)
      message: One or more granularities specified in ECT_LegacyRetirement are incorrect.
    - code: utilities.check_geographic_validity(ECT_LegacyRetirement, 'ECT_LegacyRetirement', ['EnergyConvTech'])
      message: Geographic columns have error in ECT_LegacyRetirement
    - code: utilities.check_time_validity(ECT_LegacyRetirement, 'ECT_LegacyRetirement', ['EnergyConvTech'])
      message: Time columns have error in ECT_LegacyRetirement
    - code: utilities.unique_across(ECT_LegacyRetirement,['EnergyConvTech'])
      message: In ECT_LegacyRetirement, data for one or more EnergyConvTech has duplicate entries
    - code: x_in_y(EnergyConvTech, get_col(ECT_LegacyCapacity, 'EnergyConvTech'))
      message: In ECT_LegacyRetirement, every EnergyConvTech for which retirement is given has to have capacity specified in ECT_LegacyCapacity
    - code: check_retirement_capacity(ECT_LegacyRetirement, ECT_LegacyCapacity)
      message: In ECT_LegacyRetirement, sum of retired capacity can not exceed original capacity specified in ECT_LegacyCapacity
# if there not ECT_LegacyCapacity then this can not be present.
    
  
EnergyStorTechnologies:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Storage
  optional: True
  columns:
    EnergyStorTech:
      type: str
    StoredEC:
      type: str
    DomOrImp:
      type: str
    MaxChargeRate:
      type: float
      min: 0
    MaxDischargeRate:
      type: float
      min: 0
    StorPeriodicity:
      type: str
  dependencies:
    - PhysicalPrimaryCarriers
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  validation:
    - code: unique(EnergyStorTech)
      message: In EnergyStorTechnologies,EnergyStorTech must have unique names
    - code: x_in_y(StoredEC, concat(get_col(PhysicalPrimaryCarriers,'EnergyCarrier'), get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: StoredEC in EnergyStorTechnologies must be one of those specified in Common but not from NonPhysicalPrimaryCarriers
    - code: x_in_y(DomOrImp,('EC_DOM','EC_IMP'))
      message: DomOrImp in EnergyStorTechnologies must have values one of EC_DOM or EC_IMP
    - code: x_in_y(StorPeriodicity, get_valid_stor_periodicity())
      message: StorPeriodicity in EnergyStorTechnologies must have values one of DAILY (only if DayTypes parameter is defined), SEASONAL (only if Seasons parameter is defined), ANNUAL, NEVER
    - code: check_periodicity_coarseness(EnergyStorTechnologies)
      message: StorPeriodicity in EnergyStorTechnologies must be coarser than balancing time of StoredEC
    - code: check_stortech_daytypes(EnergyStorTechnologies)
      message: Number of DAYTYPES specified in common are inconsistent with StorPeriodicity specified in EnergyStorTech

    
EST_Lifetime:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Storage
  optional: True
  columns:
    EnergyStorTech:
      type: str
    Year:
      type: int
      min: 2000
      max: 2100
    LifetimeYears:
      type: int
      min: 1
    LifetimeCycles:
      optional: True
      type: float
      min: 1
  dependencies:
    - ModelPeriod
    - EnergyStorTechnologies
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EST_Lifetime.EnergyStorTech,y=get_col(EnergyStorTechnologies,'EnergyStorTech'))
      message: In EST_Lifetime, every entry in EnergyStorTech columns should be mentioned in EnergyStorTech column of EnergyStorTechnologies    
    - code: utilities.check_time_validity(EST_Lifetime, 'EST_Lifetime', ['EnergyStorTech'])
      message: Time columns have error in EST_Lifetime
    - code: utilities.unique_across(EST_Lifetime,['EnergyStorTech'])
      message: In EST_Lifetime, data for one or more EnergyStorTech has duplicate entries
# if EnergyStortechnologies is given then this should be given and vice versa.
      
EST_CapAddBounds:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Storage
  geographic: fine
  optional: True
  columns:
    EnergyStorTech:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    Year:
      type: int
      min: 2000
      max: 2100
    MaxCap:
      type: float
      min: -1
    MinCap:
      type: float
      min: 0
  dependencies:
    - ModelPeriod
    - EST_InputsGranularity
    - EnergyStorTechnologies
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EST_CapAddBounds.EnergyStorTech,y=get_col(EnergyStorTechnologies,'EnergyStorTech'))
      message: In EST_CapAddBounds, every entry in EnergyStorTech columns should be mentioned in EnergyStorTech column of EnergyStorTechnologies    
    - code: x_in_y(x=EST_CapAddBounds.EnergyStorTech,y=get_col(EST_InputsGranularity,'EnergyStorTech'))
      message: In EST_CapAddBounds, every entry in EnergyStorTech columns should be mentioned in EnergyStorTech column of EST_InputsGranularity
    - code: check_granularity(EST_CapAddBounds, EST_InputsGranularity, 'EnergyStorTech', GSTAR=True)
      message: One or more granularities specified in EST_CapAddBounds are incorrect.
    - code: utilities.check_geographic_validity(EST_CapAddBounds, 'EST_CapAddBounds', ['EnergyStorTech'])
      message: Geographic columns have error in EST_CapAddBounds
    - code: utilities.check_time_validity(EST_CapAddBounds, 'EST_CapAddBounds', ['EnergyStorTech'])
      message: Time columns have error in EST_CapAddBounds
    - code: utilities.unique_across(EST_CapAddBounds,['EnergyStorTech'])
      message: In EST_CapAddBounds, data for one or more EnergyStorTech has duplicate entries
    - code: (MaxCap >= MinCap).sum()== (MaxCap>=0).sum() # this is to take care of -ve maxcap but +ve mincap
      message: In each row for EST_CapAddBounds MaxCap should be greater than or equal to MinCap

# if EnergyStortechnologies is given then this should be given and vice versa.

EST_DeratingDepthOfDischarge:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Storage
  optional: True
  columns:
    EnergyStorTech:
      type: str
    InstYear:
      type: int
      min: 2000
      max: 2100
    CapacityDerating:
      type: float
      min: 0
      max: 1
    DepthOfDischarge:
      type: float
      min: 0
      max: 1
  dependencies:
    - ModelPeriod
    - EnergyStorTechnologies
  filterqueries:
    - InstYear >= {ModelPeriod.StartYear.iloc[0]-1}
    - InstYear <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EST_DeratingDepthOfDischarge.EnergyStorTech,y=get_col(EnergyStorTechnologies,'EnergyStorTech'))
      message: In EST_DeratingDepthOfDischarge, every entry in EnergyStorTech columns should be mentioned in EnergyStorTech column of EnergyStorTechnologies    
    - code: utilities.unique_across(EST_DeratingDepthOfDischarge,['EnergyStorTech','InstYear'])
      message: In EST_DeratingDepthOfDischarge, EnergyStorTech and InstYear combination must not be repeated
# if EnergyStortechnologies is given then this should be given and vice versa.
    
EST_EfficiencyCost:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Storage
  geographic: coarse
  optional: True
  columns:
    EnergyStorTech:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    InstYear:
      type: int
      min: 2000
      max: 2100
    Year:
      type: int
      min: 2000
      max: 2100
    FixedCost:
      type: float
      min: 0
    Efficiency:
      type: float
      min: 0
      max: 1
  dependencies:
    - ModelPeriod
    - EST_InfoGranularity
    - EnergyStorTechnologies
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
    - InstYear >= {ModelPeriod.StartYear.iloc[0]-1}
    - InstYear <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(x=EST_EfficiencyCost.EnergyStorTech,y=get_col(EnergyStorTechnologies,'EnergyStorTech'))
      message: In EST_EfficiencyCost, every entry in EnergyStorTech columns should be mentioned in EnergyStorTech column of EnergyStorTechnologies    
    - code: x_in_y(x=EST_EfficiencyCost.EnergyStorTech,y=get_col(EST_InfoGranularity,'EnergyStorTech'))
      message: In EST_EfficiencyCost, every entry in EnergyStorTech columns should be mentioned in EnergyStorTech column of EST_InfoGranularity
    - code: check_granularity(EST_EfficiencyCost, EST_InfoGranularity, 'EnergyStorTech', GSTAR=True)
      message: One or more granularities specified in EST_EfficiencyCost are incorrect.
    - code: utilities.check_geographic_validity(EST_EfficiencyCost, 'EST_EfficiencyCost', ['EnergyStorTech','InstYear'])
      message: Geographic columns have error in EST_EfficiencyCost
    - code: utilities.check_time_validity(EST_EfficiencyCost, 'EST_EfficiencyCost', ['EnergyStorTech','InstYear'])
      message: Time columns have error in EST_EfficiencyCost
    - code: x_in_y(InstYear, range(ModelPeriod.StartYear.iloc[0]-1,ModelPeriod.EndYear.iloc[0]+1))
      message: InstYear in EST_EfficiencyCost must be between 'one year less than ModelPeriod StartYear to ModelPeriod EndYear'
    - code: utilities.unique_across(EST_EfficiencyCost,['EnergyStorTech','InstYear'])
      message: In EST_EfficiencyCost, EnergyStorTech and InstYear combination must not be repeated
    - code: (Year >= InstYear).all()
      message: In each row for ECT_EfficiencyCost, InstYear should be less than or equal to Year

# if EnergyStortechnologies is given then this should be given and vice versa.
      
EST_LegacyDetails:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Storage
  optional: True
  columns:
    EnergyStorTech:
      type: str
    ModelGeography:
      type: str
    SubGeography1:
      type: str
      optional: True
    SubGeography2:
      type: str
      optional: True
    SubGeography3:
      type: str
      optional: True
    LegacyCapacity:
      type: float
      min: 0
    BalLifetime:
      type: int
      min: 0
    BalCycles:
      type: float
      optional: True
      min: 0
  dependencies:
    - EnergyStorTechnologies
  validation:
    - code: x_in_y(x=EST_LegacyDetails.EnergyStorTech,y=get_col(EnergyStorTechnologies,'EnergyStorTech'))
      message: In EST_LegacyDetails, every entry in EnergyStorTech columns should be mentioned in EnergyStorTech column of EnergyStorTechnologies    
    - code: utilities.check_geographic_validity(EST_LegacyDetails, 'EST_LegacyDetails', ['EnergyStorTech'])
      message: Geographic columns have error in EST_LegacyDetails
    - code: check_balancing_area('EST_LegacyDetails',EST_LegacyDetails, 'EnergyStorTech')
      message: One or more EnergyStorTech in EST_LegacyDetails is not specified at geographic granularity equal to balancing area of StoredEC
    - code: utilities.unique_across(EST_LegacyDetails,['EnergyStorTech'])
      message: In EST_LegacyDetails, data for one or more EnergyStorTech has duplicate entries
#if EnergyStortechnologies is not given then should not be given
      
EC_Transfers:
  filetype: csv
  loader: rumi.io.supply.load_param
  nested: Transfers
  columns:
    EnergyCarrier:
      type: str
    ModelGeographySrc:
      type: str
    SubGeography1Src:
      type: str
      optional: True
    SubGeography2Src:
      type: str
      optional: True
    SubGeography3Src:
      type: str
      optional: True
    ModelGeographyDest:
      type: str
    SubGeography1Dest:
      type: str
      optional: True
    SubGeography2Dest:
      type: str
      optional: True
    SubGeography3Dest:
      type: str
      optional: True
    Year:
      type: int
      min: 2000
      max: 2100
    TransitCost:
      type: float
      min: 0
    TransitLoss:
      type: float
      min: 0
      max: 1
    MaxTransit:
      type: float
      min: -1
  dependencies:
    - ModelPeriod
    - PhysicalPrimaryCarriers
    - PhysicalDerivedCarriers
    - NonPhysicalDerivedCarriers
  filterqueries:
    - Year >= {ModelPeriod.StartYear.iloc[0]}
    - Year <= {ModelPeriod.EndYear.iloc[0]}
  validation:
    - code: x_in_y(EC_Transfers.EnergyCarrier, concat(get_col(PhysicalPrimaryCarriers,'EnergyCarrier'), get_col(PhysicalDerivedCarriers,'EnergyCarrier'), get_col(NonPhysicalDerivedCarriers,'EnergyCarrier')))
      message: EnergyCarrier in EC_Transfers must be one of those specified in Common but not from NonPhysicalPrimaryCarriers
    - code: check_balancing_area_src_dest('EC_Transfers', EC_Transfers, 'EnergyCarrier')
      message: Geographic granularity for one or more EnergyCarriers is incorrect in parameter EC_Transfers, check log for more information.
    - code: check_maxtransit()
      message: In EC_Transfers, MaxTransit must not be zero if source and destination geographies are same
    - code: check_geographic_validity_ec_transfers()
      message: Source or Destination Geographic columns have error in EC_Transfers
    - code: check_time_validity_ec_transfers()
      message: Time columns have error in EC_Transfers
    - code: check_unique_ec_transfers(EC_Transfers)
      message: In EC_Transfers, data for one or more EnergyCarrier has duplicate entries


UserConstraints:
  filetype: csv
  loader: rumi.io.supply.read_user_constraints
  # this is a hack, nested here is not used as folder , but just a constraint so that
  # validation happens with this additional argument, model
  nested: $model
  noheader: True
  freeflow: True
  optional: True
  validation:
    - code: len(UserConstraints) >= 1
      message: Either UserConstraints Parameter file has no lines or there is no BOUNDS line specified

    - code: constraints_loop("len(c['BOUNDS'])==2", UserConstraints, model)
      message: BOUNDS line in UserConstraints must have exactly three items

    - code: bounds_loop("isinstance(b, (float, int)) or b is None", UserConstraints, model)
      message: Both bounds in BOUNDS line in UserConstraints have to be either a number or "None"

    - code: constraints_loop("c['BOUNDS'][0] <= c['BOUNDS'][1] if (c['BOUNDS'][0] is not None) and (c['BOUNDS'][1] is not None) else True", UserConstraints)
      message: Lower bound should be less than or equal to upper bound in every BOUNDS line of UserConstraints

    - code: constraints_loop("len(c['VECTORS'])>=1", UserConstraints)
      message: In UserConstraints, every constraint should have at least one non COMMENT line that is not a BOUNDS line

    - code: vectors_loop("len(v)>=2", UserConstraints, model)
      message: In UserConstraints, any line that is not a BOUNDS line must have at least two items
    
    - code: vectors_loop("isinstance(v[-1], (float, int))",  UserConstraints, model)
      message: In UserConstraints, the last item in any line that is not a BOUNDS line must be numeric

    - code: vectors_loop("isinstance(v[0], str)", UserConstraints, model)
      message: In UserConstraints, the first item in any line that is not a BOUNDS line must be text

    - code: vectors_loop("hasattr(model, v[0])", UserConstraints, model)
      message: In UserConstraints, the first item in any line that is not a BOUNDS line must be valid model attribute

    - code: vectors_loop("isinstance(getattr(model, v[0]), Var) if hasattr(model, v[0]) else True",  UserConstraints, model)
      message: In UserConstraints, the first item in any line that is not a BOUNDS line must be valid model output

    - code: vectors_loop("getattr(model, v[0]).dim() == len(v)-2 if hasattr(model, v[0]) and isinstance(getattr(model, v[0]), Var) else True", UserConstraints, model)
      message: In UserConstraints, number of items provided in some line that is not a BOUNDS line is incorrect
      
    - code: vectors_loop("v[1:-1] in getattr(model, v[0])._data.keys() if len(v)>=4 and hasattr(model, v[0]) and isinstance(getattr(model, v[0]), Var) else True" , UserConstraints, model) 
      message: In UserConstraints, the items provided in some line that is not a BOUNDS line have incorrect values
      
    - code: vectors_loop("v[1] in getattr(model, v[0])._data.keys() if len(v)==3 and hasattr(model, v[0]) and isinstance(getattr(model, v[0]), Var) else True", UserConstraints, model)
      message: In UserConstraints, the item provided in some line that is not a BOUNDS line has incorrect value

      
global_validation:
  module: rumi.io.supply
  include:
    - Common
  validation:
    - code: validate_units_config('EnergyUnitConversion')
      message: EnergyUnitConversion is incorrect
      
    - code: ((EC_ConstraintsGranularity is not None) and PPEC) or (EC_Constraintsgranularity is not None and not PPEC) or (EC_ConstraintsGranularity is None and not PPEC)
      message: If PhysicalPrimaryCarriers is given then EC_ConstraintsGranularity has to be given 
      
    - code: (ECT_InfoGranularity is not None) and (EnergyConvTechnologies is not None) or ((ECT_InfoGranularity is None) and (EnergyConvTechnologies is None))
      message: If EnergyConvTechnologies is given then ECT_InfoGranularity must be given and vice versa
      
    - code: (ECT_InputsGranularity is not None) and (EnergyConvTechnologies is not None) or ((ECT_InputsGranularity is None) and (EnergyConvTechnologies is None))
      message: If EnergyConvTechnologies is given then ECT_InputsGranularity must be given and vice versa

    - code: (ECT_CapAddBounds is not None) and (EnergyConvTechnologies is not None) or ((ECT_CapAddBounds is None) and (EnergyConvTechnologies is None))
      message: If EnergyConvTechnologies is given then ECT_CapAddBounds must be given and vice versa

    - code: (ECT_Lifetime is not None) and (EnergyConvTechnologies is not None) or ((ECT_Lifetime is None) and (EnergyConvTechnologies is None))
      message: If EnergyConvTechnologies is given then ECT_Lifetime must be given and vice versa

    - code: (ECT_OperationalInfo is not None) and (EnergyConvTechnologies is not None) or ((ECT_OperationalInfo is None) and (EnergyConvTechnologies is None))
      message: If EnergyConvTechnologies is given then ECT_OperationalInfo must be given and vice versa

    - code: ECT_EmissionDetails is None or EnergyConvTechnologies is not None
      message: If EnergyConvTechnologies is not given ECT_EmissionDetails should not be given

    - code: (ECT_EfficiencyCostMaxAnnualUF is not None) and (EnergyConvTechnologies is not None) or ((ECT_EfficiencyCostMaxAnnualUF is None) and (EnergyConvTechnologies is None))
      message: If EnergyConvTechnologies is given then ECT_EfficiencyCostMaxAnnualUF must be given and vice versa

    - code: (ECT_Max_CUF is not None) and (EnergyConvTechnologies is not None) or ((ECT_Max_CUF is None) and (EnergyConvTechnologies is None))
      message: If EnergyConvTechnologies is given then ECT_Max_CUF must be given and vice versa
      
    - code: ECT_LegacyCapacity is None or EnergyConvTechnologies is not None
      message: If EnergyConvTechnologies is not given ECT_LegacyCapacity should not be given

    - code: ECT_LegacyRetirement is None or ECT_LegacyCapacity is not None
      message: If ECT_LegacyCapacity is not given ECT_LegacyRetirement should not be given

    - code: (EST_InfoGranularity is not None) and (EnergyStorTechnologies is not None) or ((EST_InfoGranularity is None) and (EnergyStorTechnologies is None))
      message: If EnergyStorTechnologies is given then EST_InfoGranularity must be given and vice versa

    - code: (EST_InputsGranularity is not None) and (EnergyStorTechnologies is not None) or ((EST_InputsGranularity is None) and (EnergyStorTechnologies is None))
      message: If EnergyStorTechnologies is given then EST_InputsGranularity must be given and vice versa
      
    - code: (EST_Lifetime is not None and EnergyStorTechnologies is not None) or (EST_Lifetime is None and EnergyStorTechnologies is None)
      message: If EST_Lifetime is given then EnergyStorTechnologies must be given and vice versa

    - code: (EST_CapAddBounds is not None and EnergyStorTechnologies is not None) or (EST_CapAddBounds is None  and  EnergyStorTechnologies is None)
      message: If EST_CapAddBounds is given then EnergyStorTechnologies must be given and vice versa

    - code: (EST_DeratingDepthOfDischarge is not None and EnergyStorTechnologies is not None) or (EST_DeratingDepthOfDischarge is None  and  EnergyStorTechnologies is None)
      message: If EST_DeratingDepthOfDischarge is given then EnergyStorTechnologies must be given and vice versa

    - code: (EST_EfficiencyCost is not None and EnergyStorTechnologies is not None) or (EST_EfficiencyCost is None and EnergyStorTechnologies is None)
      message: If EST_EfficiencyCost is given then EnergyStorTechnologies must be given and vice versa

    - code: EST_LegacyDetails is None  or  EnergyStorTechnologies is not None
      message: If EnergyStorTechnologies is not given EST_LegacyDetails should not be given

    - code: (PEC_Info is not None and PPEC) or (PEC_Info is None and not PPEC)
      message: If PEC_Info is given then PhysicalPrimaryCarriers must be given and vice versa

    - code: (PEC_ProdImpConstraints is not None and PhysicalPrimaryCarriers is not None) or (PEC_ProdImpConstraints is None and PhysicalPrimaryCarriers is None)
      message: If PEC_ProdImpConstraints is given then PhysicalPrimaryCarriers must be given and vice versa

    - code: (DEC_Info is not None and DEC) or (DEC_Info is None and not DEC)
      message: If DEC_Info is given then Derived EnergyCarrier  must be given and vice versa
      
    - code: ((DEC_ImpConstraints is not None) and DEC) or (DEC_ImpConstraints is None and DEC) or (DEC_ImpConstraints is None and not DEC)
      message: If DEC_ImpConstraints is given then Derived EnergyCarriers must be given
      
    - code: user_constraints_message()
      message: UserConstraints validation
